import streamlit as st
import json
import random
from typing import Dict, List, Tuple, Optional
import re

# C·∫•u h√¨nh trang
st.set_page_config(
    page_title="COVID-19 Health Assistant",
    page_icon="üè•",
    layout="wide"
)

# Load knowledge base v√† ontology
def load_knowledge_base() -> Tuple[Dict, Dict]:
    with open('data/covid.json', 'r', encoding='utf-8') as f:
        knowledge_base = json.load(f)
    with open('data/ontology/covid_ontology.json', 'r', encoding='utf-8') as f:
        ontology = json.load(f)
    return knowledge_base, ontology

# Kh·ªüi t·∫°o knowledge base v√† ontology
knowledge_base, ontology = load_knowledge_base()

class OntologyMatcher:
    def __init__(self, ontology: Dict):
        self.ontology = ontology
        self.classes = ontology['ontology']['classes']
        self.relationships = ontology['ontology']['relationships']
        self.instances = ontology['ontology']['instances']
        
    def find_related_instances(self, instance_id: str) -> List[Dict]:
        """T√¨m c√°c instance li√™n quan d·ª±a tr√™n relationships"""
        related = []
        for instance_type, instances in self.instances.items():
            for instance in instances:
                if instance_id in instance.get('id', ''):
                    related.append(instance)
        return related
    
    def get_class_properties(self, class_name: str) -> Dict:
        """L·∫•y properties c·ªßa m·ªôt class"""
        return self.classes.get(class_name, {}).get('properties', {})
    
    def find_matching_instances(self, query: str) -> List[Dict]:
        """T√¨m c√°c instance ph√π h·ª£p v·ªõi query"""
        matches = []
        query = query.lower()
        
        for instance_type, instances in self.instances.items():
            for instance in instances:
                # Ki·ªÉm tra t√™n v√† c√°c thu·ªôc t√≠nh
                if any(query in str(value).lower() for value in instance.values()):
                    matches.append(instance)
        return matches

def format_response(category: str, answer: str, related_info: List[Dict] = None, symptoms: List[str] = None, related_categories: List[Tuple[str, str]] = None) -> str:
    """
    ƒê·ªãnh d·∫°ng c√¢u tr·∫£ l·ªùi v·ªõi c·∫•u tr√∫c r√µ r√†ng v√† nhi·ªÅu th√¥ng tin li√™n quan
    """
    response = f"## {category}\n\n"
    
    # Th√™m th√¥ng tin ch√≠nh
    response += f"{answer}\n\n"
    
    # Th√™m th√¥ng tin li√™n quan t·ª´ ontology n·∫øu c√≥
    if related_info:
        response += "### Th√¥ng tin b·ªï sung t·ª´ c∆° s·ªü d·ªØ li·ªáu y t·∫ø:\n"
        for info in related_info:
            response += f"- {info.get('name', '')}: {', '.join(str(v) for v in info.values() if v != info.get('name', ''))}\n"
        response += "\n"
    
    # Th√™m th√¥ng tin v·ªÅ tri·ªáu ch·ª©ng n·∫øu c√≥
    if symptoms:
        response += "### Tri·ªáu ch·ª©ng ƒë∆∞·ª£c ƒë·ªÅ c·∫≠p:\n"
        for symptom in symptoms:
            response += f"- {symptom}\n"
        response += "\n"
    
    # Th√™m th√¥ng tin t·ª´ c√°c danh m·ª•c li√™n quan
    if related_categories:
        response += "### Th√¥ng tin li√™n quan:\n"
        for cat, ans in related_categories:
            response += f"#### {cat}\n{ans}\n\n"
    
    return response

def find_related_categories(category: str, user_input: str) -> List[Tuple[str, str]]:
    """
    T√¨m c√°c danh m·ª•c li√™n quan d·ª±a tr√™n category v√† user_input
    """
    related = []
    category_mapping = {
        "trieu_chung": ["dieu_tri", "cap_cuu", "xet_nghiem"],
        "vac_xin": ["phong_ngua", "bien_the", "nhom_nguy_co"],
        "bien_the": ["vac_xin", "phong_ngua", "trieu_chung"],
        "dieu_tri": ["trieu_chung", "cap_cuu", "xet_nghiem"],
        "phong_ngua": ["vac_xin", "dinh_duong", "lam_viec_tai_nha"],
        "nhom_nguy_co": ["vac_xin", "dieu_tri", "cap_cuu"],
        "cap_cuu": ["trieu_chung", "dieu_tri", "xet_nghiem"],
        "xet_nghiem": ["trieu_chung", "dieu_tri", "cap_cuu"],
        "dinh_duong": ["phong_ngua", "dieu_tri", "trieu_chung"],
        "lam_viec_tai_nha": ["phong_ngua", "suc_khoe_tam_than"],
        "suc_khoe_tam_than": ["lam_viec_tai_nha", "dinh_duong"],
        "mang_thai": ["vac_xin", "nhom_nguy_co", "cap_cuu"],
        "tre_em": ["vac_xin", "trieu_chung", "cap_cuu"],
        "du_lich": ["phong_ngua", "xet_nghiem", "cap_cuu"],
        "myt_duong_tinh": ["dieu_tri", "trieu_chung", "suc_khoe_tam_than"]
    }
    
    # L·∫•y c√°c danh m·ª•c li√™n quan
    related_cats = category_mapping.get(category, [])
    
    # T√¨m th√¥ng tin t·ª´ c√°c danh m·ª•c li√™n quan
    for cat in related_cats:
        if cat in knowledge_base['covid19_knowledge_base']['categories']:
            data = knowledge_base['covid19_knowledge_base']['categories'][cat]
            # T√¨m c√¢u tr·∫£ l·ªùi ph√π h·ª£p nh·∫•t trong danh m·ª•c li√™n quan
            best_match = None
            for qa in data['data']:
                if any(keyword in user_input.lower() for keyword in qa['keywords']):
                    best_match = (data['title'], qa['answer'])
                    break
            if best_match:
                related.append(best_match)
    
    return related

def find_best_match(user_input: str, ontology_matcher: OntologyMatcher) -> Tuple[Optional[str], str]:
    """
    T√¨m c√¢u tr·∫£ l·ªùi ph√π h·ª£p nh·∫•t cho c√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng
    """
    # Chu·∫©n h√≥a input
    user_input = user_input.lower()
    
    best_match = None
    best_score = 0
    related_info = []
    all_matches = set()  # S·ª≠ d·ª•ng set ƒë·ªÉ tr√°nh tr√πng l·∫∑p
    
    # T√¨m ki·∫øm trong ontology
    ontology_matches = ontology_matcher.find_matching_instances(user_input)
    if ontology_matches:
        for match in ontology_matches:
            related = ontology_matcher.find_related_instances(match['id'])
            related_info.extend(related)
    
    # T√¨m ki·∫øm trong knowledge base
    for category, data in knowledge_base['covid19_knowledge_base']['categories'].items():
        # Ki·ªÉm tra intent v·ªõi tr·ªçng s·ªë cao
        for intent in data['intent']:
            if intent in user_input:
                best_qa = random.choice(data['data'])
                score = len(intent) * 2  # Tr·ªçng s·ªë cao cho intent
                if score > best_score:
                    best_score = score
                    best_match = (data['title'], best_qa['answer'])
        
        # Ki·ªÉm tra c√°c c√¢u h·ªèi
        for qa in data['data']:
            # Ki·ªÉm tra c√¢u h·ªèi tr·ª±c ti·∫øp
            question_words = qa['question'].lower().split()
            input_words = user_input.split()
            match_count = sum(1 for word in question_words if word in input_words)
            
            if match_count >= 2:  # √çt nh·∫•t 2 t·ª´ kh·ªõp
                score = match_count * 1.5
                if score > best_score:
                    best_score = score
                    best_match = (data['title'], qa['answer'])
            
            # Ki·ªÉm tra t·ª´ kh√≥a
            for keyword in qa['keywords']:
                if keyword in user_input:
                    score = len(keyword)
                    if score > best_score:
                        best_score = score
                        best_match = (data['title'], qa['answer'])
                    # Th√™m v√†o danh s√°ch matches ƒë·ªÉ hi·ªÉn th·ªã th√¥ng tin li√™n quan
                    all_matches.add((data['title'], qa['answer']))
    
    # Tr√≠ch xu·∫•t tri·ªáu ch·ª©ng
    symptoms = extract_symptoms(user_input)
    
    # N·∫øu t√¨m th·∫•y k·∫øt qu·∫£ t·ªët nh·∫•t
    if best_match:
        category, answer = best_match
        
        # T√¨m th√¥ng tin li√™n quan
        related_categories = find_related_categories(category.lower().replace(" ", "_").replace("·ª©", "u"), user_input)
        
        return category, format_response(category, answer, related_info[:3], symptoms, related_categories[:2])
    
    # N·∫øu kh√¥ng t√¨m th·∫•y k·∫øt qu·∫£ ph√π h·ª£p
    return None, random.choice(knowledge_base['covid19_knowledge_base']['chatbot_responses']['fallback'])

def check_emergency(user_input: str) -> bool:
    """
    Ki·ªÉm tra xem c√¢u h·ªèi c√≥ li√™n quan ƒë·∫øn t√¨nh hu·ªëng kh·∫©n c·∫•p kh√¥ng
    """
    emergency_keywords = knowledge_base['covid19_knowledge_base']['nlp_patterns']['emergency_keywords']
    return any(keyword in user_input.lower() for keyword in emergency_keywords)

def extract_symptoms(user_input: str) -> List[str]:
    """
    Tr√≠ch xu·∫•t c√°c tri·ªáu ch·ª©ng t·ª´ c√¢u h·ªèi c·ªßa ng∆∞·ªùi d√πng
    """
    symptom_keywords = knowledge_base['covid19_knowledge_base']['nlp_patterns']['symptom_keywords']
    return [symptom for symptom in symptom_keywords if symptom in user_input.lower()]

# Kh·ªüi t·∫°o OntologyMatcher
ontology_matcher = OntologyMatcher(ontology)

# UI
st.title("üè• COVID-19 Health Assistant")
st.write("Xin ch√†o! T√¥i l√† tr·ª£ l√Ω ·∫£o COVID-19. T√¥i c√≥ th·ªÉ gi√∫p b·∫°n t√¨m hi·ªÉu v·ªÅ COVID-19, tri·ªáu ch·ª©ng, c√°ch ph√≤ng ng·ª´a v√† ƒëi·ªÅu tr·ªã.")

# Kh·ªüi t·∫°o chat history
if "chat" not in st.session_state:
    st.session_state.chat = []

# Input t·ª´ ng∆∞·ªùi d√πng
user_input = st.text_input("B·∫°n c·∫ßn h·ªó tr·ª£ th√¥ng tin g√¨?", key="input")

if user_input:
    # Th√™m c√¢u h·ªèi v√†o chat
    st.session_state.chat.append(("B·∫°n", user_input))
    
    # Ki·ªÉm tra t√¨nh hu·ªëng kh·∫©n c·∫•p
    if check_emergency(user_input):
        response = random.choice(knowledge_base['covid19_knowledge_base']['chatbot_responses']['emergency'])
        st.session_state.chat.append(("AI", response))
    else:
        # T√¨m c√¢u tr·∫£ l·ªùi ph√π h·ª£p
        category, answer = find_best_match(user_input, ontology_matcher)
        
        if category:
            response = answer
        else:
            response = answer
            
        # Th√™m disclaimer
        response += f"\n\n{knowledge_base['covid19_knowledge_base']['chatbot_responses']['disclaimer']}"
        
        st.session_state.chat.append(("AI", response))

# Hi·ªÉn th·ªã chat history
for speaker, msg in st.session_state.chat:
    if speaker == "B·∫°n":
        st.markdown(f"**üë§ {speaker}:** {msg}")
    else:
        st.markdown(f"**ü§ñ {speaker}:** {msg}")

# Hi·ªÉn th·ªã th√¥ng tin li√™n h·ªá
st.sidebar.title("Th√¥ng tin li√™n h·ªá kh·∫©n c·∫•p")
st.sidebar.write("üö® C·∫•p c·ª©u:", knowledge_base['covid19_knowledge_base']['chatbot_responses']['contact_info']['emergency'])
st.sidebar.write("üìû B·ªô Y t·∫ø:", knowledge_base['covid19_knowledge_base']['chatbot_responses']['contact_info']['health_ministry_hotline'])
st.sidebar.write("üìû COVID-19:", knowledge_base['covid19_knowledge_base']['chatbot_responses']['contact_info']['covid_hotline'])

# Hi·ªÉn th·ªã th√¥ng tin ontology
st.sidebar.title("Th√¥ng tin Ontology")
st.sidebar.write("S·ªë l∆∞·ª£ng classes:", len(ontology['ontology']['classes']))
st.sidebar.write("S·ªë l∆∞·ª£ng relationships:", len(ontology['ontology']['relationships']))
st.sidebar.write("S·ªë l∆∞·ª£ng instances:", sum(len(instances) for instances in ontology['ontology']['instances'].values()))
